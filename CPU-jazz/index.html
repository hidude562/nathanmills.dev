<!DOCTYPE html>
<link rel="stylesheet" href="../style.css">

<html lang="en">
<head>
	<title>nathanmills.dev - C.P.U jazz</title>
	<!-- Include -->
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
	<meta name="description" content="An algorithm generating jazz machine">
	
	<link rel="icon" href="../icon.png">
	<object type="text/html" data="../banner.html" width=100% style="height: 200px"></object>
	
</head>
<body>

<div class="main_layer">
<div class="nav">
	<!-- Include the nav table -->
	<object type="text/html" data="../nav.html" height=100%></object>
</div>

<div class="page_dis" id="mainContent">
<h1>C.P.U Jazz</h1>

<p>Like CPU Bach, a 90s' program that generates music in the style of bach, this generates music in the genre of jazz, using just pure algorithms, no machine learning.</p>


<script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>

<script>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){"use strict";var load=require("audio-loader");var player=require("sample-player");function instrument(ac,name,options){if(arguments.length===1)return function(n,o){return instrument(ac,n,o)};var opts=options||{};var isUrl=opts.isSoundfontURL||isSoundfontURL;var toUrl=opts.nameToUrl||nameToUrl;var url=isUrl(name)?name:toUrl(name,opts.soundfont,opts.format);return load(ac,url,{only:opts.only||opts.notes}).then(function(buffers){var p=player(ac,buffers,opts).connect(opts.destination?opts.destination:ac.destination);p.url=url;p.name=name;return p})}function isSoundfontURL(name){return/\.js(\?.*)?$/i.test(name)}function nameToUrl(name,sf,format){format=format==="ogg"?format:"mp3";sf=sf==="FluidR3_GM"?sf:"MusyngKite";return"https://gleitz.github.io/midi-js-soundfonts/"+sf+"/"+name+"-"+format+".js"}var Soundfont=require("./legacy");Soundfont.instrument=instrument;Soundfont.nameToUrl=nameToUrl;if(typeof module==="object"&&module.exports)module.exports=Soundfont;if(typeof window!=="undefined")window.Soundfont=Soundfont},{"./legacy":2,"audio-loader":6,"sample-player":10}],2:[function(require,module,exports){"use strict";var parser=require("note-parser");function Soundfont(ctx,nameToUrl){console.warn("new Soundfont() is deprected");console.log("Please use Soundfont.instrument() instead of new Soundfont().instrument()");if(!(this instanceof Soundfont))return new Soundfont(ctx);this.nameToUrl=nameToUrl||Soundfont.nameToUrl;this.ctx=ctx;this.instruments={};this.promises=[]}Soundfont.prototype.onready=function(callback){console.warn("deprecated API");console.log("Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()");Promise.all(this.promises).then(callback)};Soundfont.prototype.instrument=function(name,options){console.warn("new Soundfont().instrument() is deprecated.");console.log("Please use Soundfont.instrument() instead.");var ctx=this.ctx;name=name||"default";if(name in this.instruments)return this.instruments[name];var inst={name:name,play:oscillatorPlayer(ctx,options)};this.instruments[name]=inst;if(name!=="default"){var promise=Soundfont.instrument(ctx,name,options).then(function(instrument){inst.play=instrument.play;return inst});this.promises.push(promise);inst.onready=function(cb){console.warn("onready is deprecated. Use Soundfont.instrument().then()");promise.then(cb)}}else{inst.onready=function(cb){console.warn("onready is deprecated. Use Soundfont.instrument().then()");cb()}}return inst};function loadBuffers(ac,name,options){console.warn("Soundfont.loadBuffers is deprecate.");console.log("Use Soundfont.instrument(..) and get buffers properties from the result.");return Soundfont.instrument(ac,name,options).then(function(inst){return inst.buffers})}Soundfont.loadBuffers=loadBuffers;function oscillatorPlayer(ctx,defaultOptions){defaultOptions=defaultOptions||{};return function(note,time,duration,options){console.warn("The oscillator player is deprecated.");console.log("Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.");var midi=note>0&&note<129?+note:parser.midi(note);var freq=midi?parser.midiToFreq(midi,440):null;if(!freq)return;duration=duration||.2;options=options||{};var destination=options.destination||defaultOptions.destination||ctx.destination;var vcoType=options.vcoType||defaultOptions.vcoType||"sine";var gain=options.gain||defaultOptions.gain||.4;var vco=ctx.createOscillator();vco.type=vcoType;vco.frequency.value=freq;var vca=ctx.createGain();vca.gain.value=gain;vco.connect(vca);vca.connect(destination);vco.start(time);if(duration>0)vco.stop(time+duration);return vco}}Soundfont.noteToMidi=parser.midi;module.exports=Soundfont},{"note-parser":8}],3:[function(require,module,exports){module.exports=ADSR;function ADSR(audioContext){var node=audioContext.createGain();var voltage=node._voltage=getVoltage(audioContext);var value=scale(voltage);var startValue=scale(voltage);var endValue=scale(voltage);node._startAmount=scale(startValue);node._endAmount=scale(endValue);node._multiplier=scale(value);node._multiplier.connect(node);node._startAmount.connect(node);node._endAmount.connect(node);node.value=value.gain;node.startValue=startValue.gain;node.endValue=endValue.gain;node.startValue.value=0;node.endValue.value=0;Object.defineProperties(node,props);return node}var props={attack:{value:0,writable:true},decay:{value:0,writable:true},sustain:{value:1,writable:true},release:{value:0,writable:true},getReleaseDuration:{value:function(){return this.release}},start:{value:function(at){var target=this._multiplier.gain;var startAmount=this._startAmount.gain;var endAmount=this._endAmount.gain;this._voltage.start(at);this._decayFrom=this._decayFrom=at+this.attack;this._startedAt=at;var sustain=this.sustain;target.cancelScheduledValues(at);startAmount.cancelScheduledValues(at);endAmount.cancelScheduledValues(at);endAmount.setValueAtTime(0,at);if(this.attack){target.setValueAtTime(0,at);target.linearRampToValueAtTime(1,at+this.attack);startAmount.setValueAtTime(1,at);startAmount.linearRampToValueAtTime(0,at+this.attack)}else{target.setValueAtTime(1,at);startAmount.setValueAtTime(0,at)}if(this.decay){target.setTargetAtTime(sustain,this._decayFrom,getTimeConstant(this.decay))}}},stop:{value:function(at,isTarget){if(isTarget){at=at-this.release}var endTime=at+this.release;if(this.release){var target=this._multiplier.gain;var startAmount=this._startAmount.gain;var endAmount=this._endAmount.gain;target.cancelScheduledValues(at);startAmount.cancelScheduledValues(at);endAmount.cancelScheduledValues(at);var expFalloff=getTimeConstant(this.release);if(this.attack&&at<this._decayFrom){var valueAtTime=getValue(0,1,this._startedAt,this._decayFrom,at);target.linearRampToValueAtTime(valueAtTime,at);startAmount.linearRampToValueAtTime(1-valueAtTime,at);startAmount.setTargetAtTime(0,at,expFalloff)}endAmount.setTargetAtTime(1,at,expFalloff);target.setTargetAtTime(0,at,expFalloff)}this._voltage.stop(endTime);return endTime}},onended:{get:function(){return this._voltage.onended},set:function(value){this._voltage.onended=value}}};var flat=new Float32Array([1,1]);function getVoltage(context){var voltage=context.createBufferSource();var buffer=context.createBuffer(1,2,context.sampleRate);buffer.getChannelData(0).set(flat);voltage.buffer=buffer;voltage.loop=true;return voltage}function scale(node){var gain=node.context.createGain();node.connect(gain);return gain}function getTimeConstant(time){return Math.log(time+1)/Math.log(100)}function getValue(start,end,fromTime,toTime,at){var difference=end-start;var time=toTime-fromTime;var truncateTime=at-fromTime;var phase=truncateTime/time;var value=start+phase*difference;if(value<=start){value=start}if(value>=end){value=end}return value}},{}],4:[function(require,module,exports){"use strict";function b64ToUint6(nChr){return nChr>64&&nChr<91?nChr-65:nChr>96&&nChr<123?nChr-71:nChr>47&&nChr<58?nChr+4:nChr===43?62:nChr===47?63:0}function decode(sBase64,nBlocksSize){var sB64Enc=sBase64.replace(/[^A-Za-z0-9\+\/]/g,"");var nInLen=sB64Enc.length;var nOutLen=nBlocksSize?Math.ceil((nInLen*3+1>>2)/nBlocksSize)*nBlocksSize:nInLen*3+1>>2;var taBytes=new Uint8Array(nOutLen);for(var nMod3,nMod4,nUint24=0,nOutIdx=0,nInIdx=0;nInIdx<nInLen;nInIdx++){nMod4=nInIdx&3;nUint24|=b64ToUint6(sB64Enc.charCodeAt(nInIdx))<<18-6*nMod4;if(nMod4===3||nInLen-nInIdx===1){for(nMod3=0;nMod3<3&&nOutIdx<nOutLen;nMod3++,nOutIdx++){taBytes[nOutIdx]=nUint24>>>(16>>>nMod3&24)&255}nUint24=0}}return taBytes}module.exports={decode:decode}},{}],5:[function(require,module,exports){"use strict";module.exports=function(url,type){return new Promise(function(done,reject){var req=new XMLHttpRequest;if(type)req.responseType=type;req.open("GET",url);req.onload=function(){req.status===200?done(req.response):reject(Error(req.statusText))};req.onerror=function(){reject(Error("Network Error"))};req.send()})}},{}],6:[function(require,module,exports){"use strict";var base64=require("./base64");var fetch=require("./fetch");function fromRegex(r){return function(o){return typeof o==="string"&&r.test(o)}}function prefix(pre,name){return typeof pre==="string"?pre+name:typeof pre==="function"?pre(name):name}function load(ac,source,options,defVal){var loader=isArrayBuffer(source)?loadArrayBuffer:isAudioFileName(source)?loadAudioFile:isPromise(source)?loadPromise:isArray(source)?loadArrayData:isObject(source)?loadObjectData:isJsonFileName(source)?loadJsonFile:isBase64Audio(source)?loadBase64Audio:isJsFileName(source)?loadMidiJSFile:null;var opts=options||{};return loader?loader(ac,source,opts):defVal?Promise.resolve(defVal):Promise.reject("Source not valid ("+source+")")}load.fetch=fetch;function isArrayBuffer(o){return o instanceof ArrayBuffer}function loadArrayBuffer(ac,array,options){return new Promise(function(done,reject){ac.decodeAudioData(array,function(buffer){done(buffer)},function(){reject("Can't decode audio data ("+array.slice(0,30)+"...)")})})}var isAudioFileName=fromRegex(/\.(mp3|wav|ogg)(\?.*)?$/i);function loadAudioFile(ac,name,options){var url=prefix(options.from,name);return load(ac,load.fetch(url,"arraybuffer"),options)}function isPromise(o){return o&&typeof o.then==="function"}function loadPromise(ac,promise,options){return promise.then(function(value){return load(ac,value,options)})}var isArray=Array.isArray;function loadArrayData(ac,array,options){return Promise.all(array.map(function(data){return load(ac,data,options,data)}))}function isObject(o){return o&&typeof o==="object"}function loadObjectData(ac,obj,options){var dest={};var promises=Object.keys(obj).map(function(key){if(options.only&&options.only.indexOf(key)===-1)return null;var value=obj[key];return load(ac,value,options,value).then(function(audio){dest[key]=audio})});return Promise.all(promises).then(function(){return dest})}var isJsonFileName=fromRegex(/\.json(\?.*)?$/i);function loadJsonFile(ac,name,options){var url=prefix(options.from,name);return load(ac,load.fetch(url,"text").then(JSON.parse),options)}var isBase64Audio=fromRegex(/^data:audio/);function loadBase64Audio(ac,source,options){var i=source.indexOf(",");return load(ac,base64.decode(source.slice(i+1)).buffer,options)}var isJsFileName=fromRegex(/\.js(\?.*)?$/i);function loadMidiJSFile(ac,name,options){var url=prefix(options.from,name);return load(ac,load.fetch(url,"text").then(midiJsToJson),options)}function midiJsToJson(data){var begin=data.indexOf("MIDI.Soundfont.");if(begin<0)throw Error("Invalid MIDI.js Soundfont format");begin=data.indexOf("=",begin)+2;var end=data.lastIndexOf(",");return JSON.parse(data.slice(begin,end)+"}")}if(typeof module==="object"&&module.exports)module.exports=load;if(typeof window!=="undefined")window.loadAudio=load},{"./base64":4,"./fetch":5}],7:[function(require,module,exports){(function(global){(function(e){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=e()}else if(typeof define==="function"&&define.amd){define([],e)}else{var t;if(typeof window!=="undefined"){t=window}else if(typeof global!=="undefined"){t=global}else if(typeof self!=="undefined"){t=self}else{t=this}t.midimessage=e()}})(function(){var e,t,s;return function o(e,t,s){function a(n,i){if(!t[n]){if(!e[n]){var l=typeof require=="function"&&require;if(!i&&l)return l(n,!0);if(r)return r(n,!0);var h=new Error("Cannot find module '"+n+"'");throw h.code="MODULE_NOT_FOUND",h}var c=t[n]={exports:{}};e[n][0].call(c.exports,function(t){var s=e[n][1][t];return a(s?s:t)},c,c.exports,o,e,t,s)}return t[n].exports}var r=typeof require=="function"&&require;for(var n=0;n<s.length;n++)a(s[n]);return a}({1:[function(e,t,s){"use strict";Object.defineProperty(s,"__esModule",{value:true});s["default"]=function(e){function t(e){this._event=e;this._data=e.data;this.receivedTime=e.receivedTime;if(this._data&&this._data.length<2){console.warn("Illegal MIDI message of length",this._data.length);return}this._messageCode=e.data[0]&240;this.channel=e.data[0]&15;switch(this._messageCode){case 128:this.messageType="noteoff";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 144:this.messageType="noteon";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 160:this.messageType="keypressure";this.key=e.data[1]&127;this.pressure=e.data[2]&127;break;case 176:this.messageType="controlchange";this.controllerNumber=e.data[1]&127;this.controllerValue=e.data[2]&127;if(this.controllerNumber===120&&this.controllerValue===0){this.channelModeMessage="allsoundoff"}else if(this.controllerNumber===121){this.channelModeMessage="resetallcontrollers"}else if(this.controllerNumber===122){if(this.controllerValue===0){this.channelModeMessage="localcontroloff"}else{this.channelModeMessage="localcontrolon"}}else if(this.controllerNumber===123&&this.controllerValue===0){this.channelModeMessage="allnotesoff"}else if(this.controllerNumber===124&&this.controllerValue===0){this.channelModeMessage="omnimodeoff"}else if(this.controllerNumber===125&&this.controllerValue===0){this.channelModeMessage="omnimodeon"}else if(this.controllerNumber===126){this.channelModeMessage="monomodeon"}else if(this.controllerNumber===127){this.channelModeMessage="polymodeon"}break;case 192:this.messageType="programchange";this.program=e.data[1];break;case 208:this.messageType="channelpressure";this.pressure=e.data[1]&127;break;case 224:this.messageType="pitchbendchange";var t=e.data[2]&127;var s=e.data[1]&127;this.pitchBend=(t<<8)+s;break}}return new t(e)};t.exports=s["default"]},{}]},{},[1])(1)})}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],8:[function(require,module,exports){!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.NoteParser=t.NoteParser||{})}(this,function(t){"use strict";function n(t,n){return Array(n+1).join(t)}function r(t){return"number"==typeof t}function e(t){return"string"==typeof t}function u(t){return void 0!==t}function c(t,n){return Math.pow(2,(t-69)/12)*(n||440)}function o(){return b}function i(t,n,r){if("string"!=typeof t)return null;var e=b.exec(t);if(!e||!n&&e[4])return null;var u={letter:e[1].toUpperCase(),acc:e[2].replace(/x/g,"##")};u.pc=u.letter+u.acc,u.step=(u.letter.charCodeAt(0)+3)%7,u.alt="b"===u.acc[0]?-u.acc.length:u.acc.length;var o=A[u.step]+u.alt;return u.chroma=o<0?12+o:o%12,e[3]&&(u.oct=+e[3],u.midi=o+12*(u.oct+1),u.freq=c(u.midi,r)),n&&(u.tonicOf=e[4]),u}function f(t){return r(t)?t<0?n("b",-t):n("#",t):""}function a(t){return r(t)?""+t:""}function l(t,n,r){return null===t||void 0===t?null:t.step?l(t.step,t.alt,t.oct):t<0||t>6?null:C.charAt(t)+f(n)+a(r)}function p(t){if((r(t)||e(t))&&t>=0&&t<128)return+t;var n=i(t);return n&&u(n.midi)?n.midi:null}function s(t,n){var r=p(t);return null===r?null:c(r,n)}function d(t){return(i(t)||{}).letter}function m(t){return(i(t)||{}).acc}function h(t){return(i(t)||{}).pc}function v(t){return(i(t)||{}).step}function g(t){return(i(t)||{}).alt}function x(t){return(i(t)||{}).chroma}function y(t){return(i(t)||{}).oct}var b=/^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/,A=[0,2,4,5,7,9,11],C="CDEFGAB";t.regex=o,t.parse=i,t.build=l,t.midi=p,t.freq=s,t.letter=d,t.acc=m,t.pc=h,t.step=v,t.alt=g,t.chroma=x,t.oct=y})},{}],9:[function(require,module,exports){module.exports=function(player){player.on=function(event,cb){if(arguments.length===1&&typeof event==="function")return player.on("event",event);var prop="on"+event;var old=player[prop];player[prop]=old?chain(old,cb):cb;return player};return player};function chain(fn1,fn2){return function(a,b,c,d){fn1(a,b,c,d);fn2(a,b,c,d)}}},{}],10:[function(require,module,exports){"use strict";var player=require("./player");var events=require("./events");var notes=require("./notes");var scheduler=require("./scheduler");var midi=require("./midi");function SamplePlayer(ac,source,options){return midi(scheduler(notes(events(player(ac,source,options)))))}if(typeof module==="object"&&module.exports)module.exports=SamplePlayer;if(typeof window!=="undefined")window.SamplePlayer=SamplePlayer},{"./events":9,"./midi":11,"./notes":12,"./player":13,"./scheduler":14}],11:[function(require,module,exports){var midimessage=require("midimessage");module.exports=function(player){player.listenToMidi=function(input,options){var started={};var opts=options||{};var gain=opts.gain||function(vel){return vel/127};input.onmidimessage=function(msg){var mm=msg.messageType?msg:midimessage(msg);if(mm.messageType==="noteon"&&mm.velocity===0){mm.messageType="noteoff"}if(opts.channel&&mm.channel!==opts.channel)return;switch(mm.messageType){case"noteon":started[mm.key]=player.play(mm.key,0,{gain:gain(mm.velocity)});break;case"noteoff":if(started[mm.key]){started[mm.key].stop();delete started[mm.key]}break}};return player};return player}},{midimessage:7}],12:[function(require,module,exports){"use strict";var note=require("note-parser");var isMidi=function(n){return n!==null&&n!==[]&&n>=0&&n<129};var toMidi=function(n){return isMidi(n)?+n:note.midi(n)};module.exports=function(player){if(player.buffers){var map=player.opts.map;var toKey=typeof map==="function"?map:toMidi;var mapper=function(name){return name?toKey(name)||name:null};player.buffers=mapBuffers(player.buffers,mapper);var start=player.start;player.start=function(name,when,options){var key=mapper(name);var dec=key%1;if(dec){key=Math.floor(key);options=Object.assign(options||{},{cents:Math.floor(dec*100)})}return start(key,when,options)}}return player};function mapBuffers(buffers,toKey){return Object.keys(buffers).reduce(function(mapped,name){mapped[toKey(name)]=buffers[name];return mapped},{})}},{"note-parser":15}],13:[function(require,module,exports){"use strict";var ADSR=require("adsr");var EMPTY={};var DEFAULTS={gain:1,attack:.01,decay:.1,sustain:.9,release:.3,loop:false,cents:0,loopStart:0,loopEnd:0};function SamplePlayer(ac,source,options){var connected=false;var nextId=0;var tracked={};var out=ac.createGain();out.gain.value=1;var opts=Object.assign({},DEFAULTS,options);var player={context:ac,out:out,opts:opts};if(source instanceof AudioBuffer)player.buffer=source;else player.buffers=source;player.start=function(name,when,options){if(player.buffer&&name!==null)return player.start(null,name,when);var buffer=name?player.buffers[name]:player.buffer;if(!buffer){console.warn("Buffer "+name+" not found.");return}else if(!connected){console.warn("SamplePlayer not connected to any node.");return}var opts=options||EMPTY;when=Math.max(ac.currentTime,when||0);player.emit("start",when,name,opts);var node=createNode(name,buffer,opts);node.id=track(name,node);node.env.start(when);node.source.start(when);player.emit("started",when,node.id,node);if(opts.duration)node.stop(when+opts.duration);return node};player.play=function(name,when,options){return player.start(name,when,options)};player.stop=function(when,ids){var node;ids=ids||Object.keys(tracked);return ids.map(function(id){node=tracked[id];if(!node)return null;node.stop(when);return node.id})};player.connect=function(dest){connected=true;out.connect(dest);return player};player.emit=function(event,when,obj,opts){if(player.onevent)player.onevent(event,when,obj,opts);var fn=player["on"+event];if(fn)fn(when,obj,opts)};return player;function track(name,node){node.id=nextId++;tracked[node.id]=node;node.source.onended=function(){var now=ac.currentTime;node.source.disconnect();node.env.disconnect();node.disconnect();player.emit("ended",now,node.id,node)};return node.id}function createNode(name,buffer,options){var node=ac.createGain();node.gain.value=0;node.connect(out);node.env=envelope(ac,options,opts);node.env.connect(node.gain);node.source=ac.createBufferSource();node.source.buffer=buffer;node.source.connect(node);node.source.loop=options.loop||opts.loop;node.source.playbackRate.value=centsToRate(options.cents||opts.cents);node.source.loopStart=options.loopStart||opts.loopStart;node.source.loopEnd=options.loopEnd||opts.loopEnd;node.stop=function(when){var time=when||ac.currentTime;player.emit("stop",time,name);var stopAt=node.env.stop(time);node.source.stop(stopAt)};return node}}function isNum(x){return typeof x==="number"}var PARAMS=["attack","decay","sustain","release"];function envelope(ac,options,opts){var env=ADSR(ac);var adsr=options.adsr||opts.adsr;PARAMS.forEach(function(name,i){if(adsr)env[name]=adsr[i];else env[name]=options[name]||opts[name]});env.value.value=isNum(options.gain)?options.gain:isNum(opts.gain)?opts.gain:1;return env}function centsToRate(cents){return cents?Math.pow(2,cents/1200):1}module.exports=SamplePlayer},{adsr:3}],14:[function(require,module,exports){"use strict";var isArr=Array.isArray;var isObj=function(o){return o&&typeof o==="object"};var OPTS={};module.exports=function(player){player.schedule=function(time,events){var now=player.context.currentTime;var when=time<now?now:time;player.emit("schedule",when,events);var t,o,note,opts;return events.map(function(event){if(!event)return null;else if(isArr(event)){t=event[0];o=event[1]}else{t=event.time;o=event}if(isObj(o)){note=o.name||o.key||o.note||o.midi||null;opts=o}else{note=o;opts=OPTS}return player.start(note,when+(t||0),opts)})};return player}},{}],15:[function(require,module,exports){"use strict";var REGEX=/^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;function regex(){return REGEX}var SEMITONES=[0,2,4,5,7,9,11];function parse(str,isTonic,tuning){if(typeof str!=="string")return null;var m=REGEX.exec(str);if(!m||!isTonic&&m[4])return null;var p={letter:m[1].toUpperCase(),acc:m[2].replace(/x/g,"##")};p.pc=p.letter+p.acc;p.step=(p.letter.charCodeAt(0)+3)%7;p.alt=p.acc[0]==="b"?-p.acc.length:p.acc.length;p.chroma=SEMITONES[p.step]+p.alt;if(m[3]){p.oct=+m[3];p.midi=p.chroma+12*(p.oct+1);p.freq=midiToFreq(p.midi,tuning)}if(isTonic)p.tonicOf=m[4];return p}function midiToFreq(midi,tuning){return Math.pow(2,(midi-69)/12)*(tuning||440)}var parser={parse:parse,regex:regex,midiToFreq:midiToFreq};var FNS=["letter","acc","pc","step","alt","chroma","oct","midi","freq"];FNS.forEach(function(name){parser[name]=function(src){var p=parse(src);return p&&typeof p[name]!=="undefined"?p[name]:null}});module.exports=parser},{}]},{},[1]);
</script>

<h2>Key change probabilities:</h2>
<p>Note: values do not have to add up to 1, one value can be 600 and the other can be 400 for example and it will be automatically be translated to a normal probability in the program</p>
<br>
<form id="probabilityForm">
    <label for="probability0">+6 flats/sharps</label>
    <input type="number" id="probability0" name="probability0" min="0" max="1" step="0.001" value="0.012"><br>

    <label for="probability1">+5 flats</label>
    <input type="number" id="probability1" name="probability1" min="0" max="1" step="0.001" value="0.038"><br>

    <label for="probability2">+4 flats</label>
    <input type="number" id="probability2" name="probability2" min="0" max="1" step="0.001" value="0.077"><br>

    <label for="probability3">+3 flats</label>
    <input type="number" id="probability3" name="probability3" min="0" max="1" step="0.001" value="0.051"><br>

    <label for="probability4">+2 flats</label>
    <input type="number" id="probability4" name="probability4" min="0" max="1" step="0.001" value="0.061"><br>

    <label for="probability5">+1 flat</label>
    <input type="number" id="probability5" name="probability5" min="0" max="1" step="0.001" value="0.131"><br>

    <label for="probability6">No change</label>
    <input type="number" id="probability6" name="probability6" min="0" max="1" step="0.001" value="0.219"><br>

    <label for="probability7">+1 sharp</label>
    <input type="number" id="probability7" name="probability7" min="0" max="1" step="0.001" value="0.061"><br>

    <label for="probability8">+2 sharps:</label>
    <input type="number" id="probability8" name="probability8" min="0" max="1" step="0.001" value="0.197"><br>

    <label for="probability9">+3 sharps</label>
    <input type="number" id="probability9" name="probability9" min="0" max="1" step="0.001" value="0.056"><br>

    <label for="probability10">+4 sharps</label>
    <input type="number" id="probability10" name="probability10" min="0" max="1" step="0.001" value="0.032"><br>

    <label for="probability11">+5 sharps</label>
    <input type="number" id="probability11" name="probability11" min="0" max="1" step="0.001" value="0.057"><br>
  </form>

<script>
	function retrieveProbabilities() {
      var probabilities = [];
      for (var i = 0; i < 12; i++) {
        var probability = parseFloat(document.getElementById("probability" + i).value);
        probabilities.push(probability);
      }
      return probabilities;
    }
</script>

<h2>Rhythm Parameters</h2>

<p>Parameters to modify the rhythm for the solo</p>

<label for="probability11">Rhythm recursion</label>
<input type="number" id="rhythmRecursion" name="probability11" min="0" max="10" step="1" value="3"><br>

<label for="probability11">Note subdivision probability</label>
<input type="number" id="subdivisionProbability" name="probability11" min="0" max="1.0" step="1" value="0.99"><br>

<label for="probability11">Syncopation solo probaility</label>
<input type="number" id="syncopationProbability" name="probability11" min="0" max="1.0" step="1" value="0.1"><br>

<h2>Solo's note parameters</h2>

<p>The solo generates its note values in 3 note segments, rating them based off how random they are, then combining these probabilities with its previous segments. For example, a segment could be C-D-E, C-E-G, and lotsa things</p>

<label for="probability11">Chromatic (C-C#-D)</label>
<input type="number" id="chromaticProb" name="probability11" min="0" max="1.0" step="1" value="1.5"><br>

<label for="probability11">Scale-like (C-D-Eb)</label>
<input type="number" id="scaleProb" name="probability11" min="0" max="1.0" step="1" value="0.5"><br>

<label for="probability11">Diminished/aug triad (C-E-Ab), (C-D#-F#)</label>
<input type="number" id="dimProb" name="probability11" min="0" max="1.0" step="1" value="0.5"><br>

<label for="probability11">Triad (C-E-G)</label>
<input type="number" id="triadProb" name="probability11" min="0" max="1.0" step="1" value="1.0"><br>

<label for="probability11">Reverse scale direction (B-C-B)</label>
<input type="number" id="reverseProb" name="probability11" min="0" max="1.0" step="1" value="1.5"><br>

<label for="probability11">Major resolve (D-B-C)</label>
<input type="number" id="resolveProb" name="probability11" min="0" max="1.0" step="1" value="1.0"><br>

<label for="probability11">Fiths sequence (C-G-D)</label>
<input type="number" id="fithsProb" name="probability11" min="0" max="1.0" step="1" value="0.4"><br>

<label for="probability11">Randomness</label>

<input type="number" id="randomness" name="probability11" min="0" max="1.0" step="1" value="0.01"><br>

<h2>Misc.</h2>

<label for="probability11">BPM</label>
<input type="number" id="BPMinput" name="probability11" min="10" max="1000" step="1" value="150"><br>

<label for="probability11">Measures</label>
<input type="number" id="measaures" name="probability11" min="1" max="1000" step="1" value="64"><br>

<h2>Fun</h2>

<label for="probability11">Extra instruments in solo</label>
<input type="number" id="soloExtraInstruments" name="probability11" min="0" max="1" step="1" value="0"><br>

<label for="probability11">Piano style</label>
<input type="number" id="style" name="probability11" min="10" max="1000" step="1" value="150"><br>

<br>

<button id="play-chord">Generate & play!</button>
<p id="completionProgress"></p>


<canvas id="sheetMusic" width="600" height="400"></canvas>

<script>
    const canvas = document.getElementById('sheetMusic');
    const ctx = canvas.getContext('2d');

    // Load the treble clef image
    const trebleClef = new Image();
	const bassClef = new Image();
	
	const quarterNote = new Image();
	
	const flatSign = new Image();
	const sharpSign = new Image();
	
	const lineSpacing = 8;
    const topMargin = 64;
	const xMargin = 32+8
    const partSpacing = 64
    const numPartLines = 2;
    const barSpacing = 120;
	
    trebleClef.src = 'treble.png';
	bassClef.src = 'bass.png';
	quarterNote.src = 'quarter.png';
	flatSign.src = 'flat.png';
	sharpSign.src = 'sharp.png';
	
	
	
    function drawSheetMusic(piece, beat, key) {
	canvas.width = document.getElementById("mainContent").clientWidth - 60
	console.log(window.width)
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
	  
	const beatToXOffset = beat / 4 * barSpacing
	  
	  
	function drawMidiNote(note, beatNum, partNum, useSharps, isBassClef) {
		
		var asCMajor = note
		var noteBaseKey = note%12
		var CmajorKeys = [0, 2, 4, 5, 7, 9, 11]
		var usingAccidental = false;
		
		if(!CmajorKeys.includes(noteBaseKey)) {
			usingAccidental = true
			if(useSharps) {
				asCMajor-=1
			} else {
				asCMajor+=1
			}
		}
		
		var octave = Math.floor(note/12) - 5
		var noteIndexOnStaff = CmajorKeys.indexOf(asCMajor%12)
		if(isBassClef) {
			noteIndexOnStaff = (noteIndexOnStaff - 2) % 12
			octave+=2
		}
		var relativeStaffY = -((noteIndexOnStaff-3) * lineSpacing/2 + (octave*7*lineSpacing/2))
		
		
		var y = relativeStaffY + (partNum * partSpacing) + topMargin
		var x = beatNum * barSpacing / 4  - beatToXOffset + xMargin
		ctx.drawImage(quarterNote, x, y);
		if(usingAccidental) {
			if(useSharps) {
				ctx.drawImage(sharpSign, x, y);
			} else {
				ctx.drawImage(flatSign, x, y);
			}
		}
	}
	  

      // Draw the horizontal lines
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      
      for (let i = 0; i < 5; i++) {
		for(let j = 0; j < numPartLines; j++) {
			const y = topMargin + i * lineSpacing;
			ctx.beginPath();
			ctx.moveTo(0, y + (j*partSpacing));
			ctx.lineTo(canvas.width + xMargin, y + (j*partSpacing));
			ctx.stroke();
		}
      }
	  
	  for (let i = 0; i < piece.phraseLength; i += 1) {
		for(let j = 0; j < numPartLines; j++) {
			ctx.beginPath();
			ctx.moveTo(i*barSpacing - beatToXOffset + xMargin, topMargin + (j*partSpacing));
			ctx.lineTo(i*barSpacing - beatToXOffset + xMargin, topMargin + 4 * lineSpacing + (j*partSpacing));
			ctx.stroke();
		}
	  }
	  
	  // Actual content
	  for (let i = Math.floor(beat/4); i < piece.phraseLength; i += 1) {
		for(let j = 0; j < numPartLines; j++) {
			ctx.beginPath();
			ctx.moveTo(i*barSpacing - beatToXOffset + xMargin, topMargin + (j*partSpacing));
			ctx.lineTo(i*barSpacing - beatToXOffset + xMargin, topMargin + 4 * lineSpacing + (j*partSpacing));
			ctx.stroke();
		}
		
		ctx.font = '16px san-serif';
		for(let chord of piece.measures[i].chords)
			ctx.fillText(chord.chord, i*barSpacing - beatToXOffset + xMargin, topMargin-16);
		
		useSharps = piece.measures[i].chords[0].key >= 0
		for(let soloNote of piece.measures[i].soloNotes) {
			drawMidiNote(soloNote.note, soloNote.beat + i*4, 0, useSharps, false)
		}
		
		for(let bassNote of piece.measures[i].bassNotes) {
			var bassAsMidi = Tonal.Midi.toMidi(bassNote.note+"2")
			drawMidiNote(bassAsMidi, bassNote.beat + i*4, 1, useSharps, true)
		}
      }

      // Draw the treble clef
      const trebleClefY = topMargin - 16;
	  const bassClefY = topMargin - 16 + partSpacing;
	  const clefsX = 0
	  
      ctx.drawImage(trebleClef, clefsX, trebleClefY);
	  ctx.drawImage(bassClef, clefsX, bassClefY);
    }
</script>

<script>

var sleepSetTimeout_ctrl;

function sleep(ms) {
    clearInterval(sleepSetTimeout_ctrl);
    return new Promise(resolve => sleepSetTimeout_ctrl = setTimeout(resolve, ms));
}
</script>

<script>
        // Define drum notes
        const kick = 36;
        const snare = 38;
        const hihat = 42;
		var swingValue = 0.5

        // Use the AudioContext interface to control audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();

        // Initialize the piano and drum instruments
        let piano, bass, sax, drum;

        // Function to play a chord using soundfont-player
        function playChord(chord,bpm) {
            // Play each note in the chord
			var timeExtra = 0
			var quarterNote = 60 / bpm;
            chord.forEach(function (note) {
                piano.play(note, audioContext.currentTime + quarterNote * swingValue, { duration: quarterNote / 2});
				timeExtra+=0.0
            });
			
			chord.forEach(function (note) {
                piano.play(note, audioContext.currentTime + quarterNote * 2, { duration: quarterNote * 2});
				timeExtra+=0.0
            });
        }
		
		function playChordLame(chord,length) {
            // Play each note in the chord
			var timeExtra = 0
            chord.forEach(function (note) {
                piano.play(note, audioContext.currentTime + timeExtra, { duration: length - timeExtra});
				timeExtra+=0.0
            });
        }
        
        function playBass(note, length) {
            bass.play(note, audioContext.currentTime, { duration: length });
        }
		
		function playSolo(solo, bpm) {
			const beatDuration = 60 / bpm;
			for(var i = 0; i < solo.length; i++) {
				var current = solo[i]
				var currentBeat = solo[i]
				
				var playLength = 4 - solo[i].beat
				if(i != solo.length-1)
					playLength = solo[i+1].beat - current.beat
				
				
				sax.play(current.note, audioContext.currentTime + (beatDuration * current.beat), { duration: ( playLength * beatDuration)});
			}
		}

        // Function to play a simple drum loop
        function playDrumLoop(bpm) {
            const beatDuration = 60 / bpm; // Duration of one beat in seconds
            let time = audioContext.currentTime;

            // Simple 4-beat drum pattern: Kick on 1 & 3, Snare on 2 & 4, Hi-hat on every beat
            for (let i = 0; i < 4; i++) {
                // Kick on beats 1 and 3
                if (i % 2 == 1) {
                    drum.play(kick, time + (i+swingValue) * beatDuration, { duration: beatDuration});
                }
                // Snare on beats 2 and 4
                else {
                    drum.play(snare, time + i * beatDuration, { duration: beatDuration});
                    drum.play(snare, time + i * beatDuration, { duration: beatDuration});
                }
                // Hi-hat on every beat
                drum.play(hihat, time + i * beatDuration, { duration: beatDuration });
            }
        }

        // Load the piano and drum instruments when the page loads
        Soundfont.instrument(audioContext, 'acoustic_grand_piano').then(function (instrument) {
            piano = instrument;
            // Enable the button once the piano is loaded
            document.getElementById('play-chord').disabled = false;
        });
        
        // Load the piano and drum instruments when the page loads
        Soundfont.instrument(audioContext, 'acoustic_bass', { soundfont: 'FluidR3_GM', gain: 3 }).then(function (instrument) {
            bass = instrument;
        });
		
		Soundfont.instrument(audioContext, 'trumpet', { soundfont: 'FluidR3_GM', gain: 1 }).then(function (instrument) {
            sax = instrument;
        });
	
	// TODO: actual precussion
        Soundfont.instrument(audioContext, 'woodblock', { soundfont: 'FluidR3_GM', gain: 0.1 }).then(function (instrument) {
            drum = instrument;
        });

        
        // Disable the button until the instruments are loaded
        document.getElementById('play-chord').disabled = true;
</script>



<script>
	/*
	A tree based approach to rhythm generation
	Starts with a whole note and then procedes to subdivide everything
	
	The rhythms are rearanged in a specific way depending on the phrase length
	
	Lets say the piece has a phrase length of 8
	So for example, the rhythm of Measure 4 is the direct sibling of measure 1
	
	
	Key:
		W - Whole note
		F - Dotted half note
		H - Half note
		D - Dotted quarter note
		Q - Quarter note
		E - Eigth note
	
	*/
	class Tree {
		static weightedPick(payload) {
			/*
			[
			{value: "DE", prob: 1}
			]
			*/
			
			var random = Math.random();
			for(var i = 0; i < payload.length; i++) {
				random-=payload[i].prob
				if(random<=0)
					return payload[i].value
			}
		}
		subdivideRhythm() {
			var newRhythm = "";
			var syncopationProbability = document.getElementById("syncopationProbability").value
			for(var i = 0; i < this.rhythm.length; i++) {
				var newSubdivided = ""
				if(Math.random() < parseFloat(document.getElementById("subdivisionProbability").value)) {
					switch(this.rhythm.slice(i, i+1)) {
						case 'W':
							//console.log("W")
							newSubdivided = Tree.weightedPick([{value: "HH", prob: 0.7}, {value: "FQ", prob: 0.15}, {value: "QF", prob: 0.15}])
							break
						case 'H':
							newSubdivided = Tree.weightedPick([{value: "SED", prob: syncopationProbability}, {value: "AED", prob: syncopationProbability}, {value: "QQ", prob: 0.7}, {value: "DE", prob: 0.3}])
							break
						case 'Q':
							newSubdivided = Tree.weightedPick([{value: "EE", prob: 0.5}, {value: "Q", prob: 0.5}])
							break
						default:
							newSubdivided = this.rhythm.slice(i, i+1);
							break
					}
				} else {
					newSubdivided=this.rhythm.slice(i, i+1)
				}
				
				newRhythm+=newSubdivided
			}
			
			this.rhythm = newRhythm
		}
		// Only the children at the bottom-most branch
		getAllBaseChildren() {
			if(this.currentDepth < this.maxDepth) {
				return (this.branches[0].getAllBaseChildren()).concat(this.branches[1].getAllBaseChildren())
			}
			return [this];
		}
		getChildrenInOrder() {
			var children = this.getAllBaseChildren()
			children.sort((a, b) => parseFloat(a.order) - parseFloat(b.order));
			var rhythm = ""
			return children;
		}
		getRhythmArray() {
			var children = this.getChildrenInOrder();
			var arr = []
			for(let child of children) {
				var rhythmStr = child.rhythm;
				console.log(child.rhythm);
				for(var i = 0; i < rhythmStr.length; i++) {
					switch(rhythmStr.slice(i, i+1)) {
						case 'W':
							arr.push(4);
							break;
						case 'H':
							arr.push(2);
							break;
						case 'Q':
							arr.push(1);
							break;
						case 'S':
							arr.push(0.5);
							break;
						case 'A':
							arr.push(1);
							break;
						case 'F':
							arr.push(3);
							break;
						case 'D':
							arr.push(1.5);
							break;
						case 'E':
							arr.push(0.5);
							break;
					}
				}
			}
			
			return arr;
		}
		getThisOrder() {
			var multiplicity = 1;
			var measureNumber = this.measures-1;
			for(let isRight of this.directions) {
				if(!isRight) {
					measureNumber-=multiplicity
				} else {
				
				}
				multiplicity*=2
			}
			return measureNumber;
		}
		constructor(payload) {
			if(payload.parent != undefined) {
				var parent = payload.parent;
				this.maxDepth=parent.maxDepth;
				this.measures=parent.measures
				this.currentDepth = parent.currentDepth+1;
				this.isRight =  payload.isRight;
				this.directions = []
				for(var item of parent.directions)
					this.directions.push(item);
				this.directions.push(this.isRight);
				this.rhythm = parent.rhythm;
				this.order = this.getThisOrder()
				
				if(!this.isRight)
					this.subdivideRhythm()
				
				if(this.currentDepth < this.maxDepth) {
					this.branches = [new Tree({parent: this, isRight: false}), new Tree({parent: this, isRight: true})];
				}
			} else {
				this.maxDepth=3;
				this.measures=Math.pow(2,this.maxDepth)
				this.currentDepth = parseInt(document.getElementById("subdivisionProbability").value);
				this.rhythm = "W"
				this.isRight = true
				this.directions = []
				this.branches = [new Tree({parent: this, isRight: false}), new Tree({parent: this, isRight: true})];
			}
		}
	}
</script>




<script>
	class Measure {
		constructor(chords) {
			this.chords = chords
			this.bassNotes = []
			this.soloNotes = []
		}
	}
	class Chord {
		constructor(chord, key) {
			this.chord = chord
			this.key = key
			this.likeness = 0
		}
		
		getKeyDistance(otherChord) {
			// Assuming the key is a number representing the number of sharps (+) or flats (-)
			let distance = otherChord.key - this.key;
			
			if (distance > 6)
			    distance -= 12;
			else if (distance < -6)
			    distance += 12;

			return distance;
		    }
		
		getChordPoints(otherChord) {
			let points = 0;

			// Get the notes of both chords
			var notesThisChord = Tonal.Chord.get(this.chord).notes;
			var notesOtherChord = Tonal.Chord.get(otherChord.chord).notes;
			
			for(var i = 0; i < notesThisChord.length; i++) {
				notesThisChord[i] = Tonal.Midi.toMidi(notesThisChord[i] + "5")
			}
			
			for(var i = 0; i < notesOtherChord.length; i++) {
				notesOtherChord[i] = Tonal.Midi.toMidi(notesOtherChord[i] + "5")
			}

			// Calculate the key signature distance
			const keyDistance = Math.abs(this.getKeyDistance(otherChord));

			// Determine how to calculate points based on key distance
			// TODO: keydistance of 2 is kinda an edge case and so it should be handled diferently
			if (keyDistance > 1) {
			    // Optimize for similar notes
			    notesOtherChord.forEach(note => {
				if (notesThisChord.includes(note)) {
				    // Check if the note is the 7th of the chord
				    if (notesOtherChord[3] === note) {
				        points += 0.75; // 7th of the chord
				    } else {
				        points += 1; // Other common notes
				    }
				}
			    });
			} else {
			    // Optimize for different notes
			    notesOtherChord.forEach(note => {
				if (!notesThisChord.includes(note)) {
				    points += 1; // Different notes
				} else {
				    // Check if the note is the 7th of the chord
				    if (notesOtherChord[3] === note) {
				        points -= 0.75; // 7th of the chord
				    } else {
				        points -= 1; // Common notes
				    }
				}
			    });
			}

			return points;
		    }
	}
	class Phrase {
		constructor(key, measures) {
			this.measures = [];
			this.phraseLength = measures
			this.homekey = key;
			this.currentKey = key;
			this.measureOn = 0;
			this.bpm = parseFloat(document.getElementById("BPMinput").value);
			
			this.soloistLowerRange =  52
			this.soloistUpperRange =  85
			
			this.currentSoloistMidiNote = 0;
		}
		getKeychangeLikeness() {
			var data = retrieveProbabilities()
			// Check if sum adds up to 1, if it doesn't, make it do that
			var sum = 0
			for(var i = 0; i < data.length; i++) {
				sum+=data[i]
			}
			if(sum!=1.0) {
				for(var i = 0; i < data.length; i++) {
					data[i]/=sum
				}
			}
			
			return data
		}
		keyChange() {
			var random = Math.random()
			var sum = 0.0
			var i = 0
			
			var keyChangeLikeness = this.getKeychangeLikeness()
			while(sum < random) {
				i+=1
				sum+=keyChangeLikeness[i]
			}
			
			this.currentKey += i-6
			
			
			if(this.currentKey < -6) {
				this.currentKey+=12
			}
			if(this.currentKey > 6) {
				this.currentKey-=12
			}
			
		}
		getFlatsSharps(passedKey) {
			var returnStr = ""
			for(var i = 0; i < Math.abs(passedKey); i++) {
				if(passedKey < 0) {
					returnStr+="b"
				} else {
					returnStr+="#"
				}
			}
			return returnStr
		}
		getNextChordRankings(previousChords) {
			/*
			TODO: breaks upon going from flats to sharps
			
			This will return a numerical value as a point based system and chord depending on a few factors
			
			If the key signature distance is more than two, the two chords should try optimizing for things in common, for example if the distance is +3, and the previous chord is Cmaj7, the two chords that have the most in common (An E and a B) would be C#min7 and E7,
			
			In addition, to the previous example, the 7th of the chord should be worth 3/4 points, making E7 more valuable than C#min7 since the B of E7 is a fifth and not a 7th
			
			The closer the key signature distance (if abs(getKeyDistance) is less than or equal to two), the more different notes the two chords should have
			
			So, for example if the first chord is Cmaj7, and the next chord is in the same key, the most valuable chord would be Bm7b5 since there is nothing in common with it and Cmaj7. The second most valuable chord would be Dm7 since it only shares the C, and since it is the 7th of the chord, it would only count against its points by 3/4
			
			
			
			An example
			
			previousChords -> [new Chord(Cmaj7, 0)]
			
			Current key -> -4 (Ab major)
			
			
			Optimize for similar notes...
			
			Abmaj7 -> Ab C Eb G
			
			Cmaj7 ->  C E G B
			
			2 in common, C (+1 point) and G (+0.75 points)
			
			
			----------
			
			
			Cmin7 -> C Eb G Bb
			
			Cmaj7 -> C E G B
			
			2 in common, C (+1 point) and G (+1 point)
			
			Most valuable chords:
			
			[Chord(Cmin7, -4, 2), Chord(Cmin7, -4, 1.75)...]
			
			
			*/
			
			// Define a list of possible chords to consider
			// Get all chords in the current key
			var scale = Tonal.Key.majorKey("C");
			if(this.currentKey!=0)
			scale = Tonal.Key.majorKey(Tonal.Key.majorTonicFromKeySignature(this.getFlatsSharps(this.currentKey)));
			
			const chordsInKey = scale.chords;

			// Create an array to hold the chords with their calculated points
			let chordRankings = [];

			// Calculate points for each chord in the key
			chordsInKey.forEach(chordName => {
			    // Create a Chord instance for the chord in the current key
			    const chord = new Chord(chordName, this.currentKey, 0);

			    // Calculate points based on the previous chords
			    let totalPoints = 0;
			    previousChords.forEach(prevChord => {
				totalPoints += prevChord.getChordPoints(chord);
			    });

			    // Add the chord and its points to the rankings array
			    chord.likeness = totalPoints;
			    chordRankings.push(chord);
			});

			// Sort the chords by their points in descending order
			chordRankings.sort((a, b) => b.likeness - a.likeness);

			return chordRankings;
		}
		getNextChord(previousChords) {
			var rankings = this.getNextChordRankings(previousChords)
			//console.log(rankings)
			var i = 0
			while(rankings[i].likeness > 1.75) {
				i++
			}
			return rankings[Math.round(Math.random() * i)];
		}
		playMeasure() {
			// Store the current measure for reference in the setTimeout callbacks
			var currentMeasure = this.measures[this.measureOn  % this.phraseLength];
			var chords = currentMeasure.chords
			drawSheetMusic(this,(this.measureOn*4) % (this.phraseLength * 4))
			
			var secondsInMeasure = 60.0 / this.bpm * 4
			
			playDrumLoop(this.bpm)
			
			if(chords.length == 1) {
				var chordNotes =Tonal.Chord.get(chords[0].chord).notes;
				var chordMidiNotes = []
				for(var i = 0; i < chordNotes.length; i++) {
					chordMidiNotes.push(Tonal.Midi.toMidi(chordNotes[i]+"4"))
				}
				playChord(chordMidiNotes, this.bpm);
			}
			
			if(this.measures[this.measureOn  % this.phraseLength].soloNotes.length > 0) {
				playSolo(this.measures[this.measureOn  % this.phraseLength].soloNotes, this.bpm)
			}

			// Calculate the length of each bass note in seconds
			var lenBassNote = secondsInMeasure / currentMeasure.bassNotes.length;

			// Loop through each bass note and schedule them to be played
			for (var i = 0; i < currentMeasure.bassNotes.length; i++) {
			    // Calculate the delay for the current bass note
			    var delay = lenBassNote * i * 1000; // Convert seconds to milliseconds

			    // Use a closure to capture the current bass note and its length
			    (function(bassNote, noteLength) {
				setTimeout(function() {
				    playBass(Tonal.Midi.toMidi(bassNote.note + "2"), noteLength);
				}, delay);
			    })(currentMeasure.bassNotes[i], lenBassNote);
			}
			this.measureOn+=1
			
		}
		writeBassNote(time, note) {
			try {
				// Assuming a 4/4 time signature
				const beatsPerMeasure = 4;
				const totalBeats = time;

				// Calculate which measure the note falls into
				const measureIndex = Math.floor(totalBeats / beatsPerMeasure);
				// Calculate the beat within the measure
				const beatWithinMeasure = totalBeats % beatsPerMeasure;

				// Ensure the measure exists
				if (measureIndex >= this.measures.length) {
				    console.error("Measure does not exist.");
				    return;
				}

				// Get the measure
				const measure = this.measures[measureIndex];

				// If the bassNotes array does not exist for the measure, create it
				if (!measure.bassNotes) {
				    measure.bassNotes = [];
				}

				// Save the note at the appropriate beat within the measure
				// We'll use an object to store the beat and the note
				measure.bassNotes.push({
				    beat: beatWithinMeasure,
				    note: note
				});

				// Sort the bass notes by beat to maintain the correct order
				measure.bassNotes.sort((a, b) => a.beat - b.beat);
			} catch(err) {
			
			}
		}
		
		writeSoloNote(time, note) {
			try {
				// Assuming a 4/4 time signature
				const beatsPerMeasure = 4;
				const totalBeats = time;

				// Calculate which measure the note falls into
				const measureIndex = Math.floor(totalBeats / beatsPerMeasure);
				// Calculate the beat within the measure
				const beatWithinMeasure = totalBeats % beatsPerMeasure;

				// Ensure the measure exists
				if (measureIndex >= this.measures.length) {
				    console.error("Measure does not exist.");
				    return;
				}

				// Get the measure
				const measure = this.measures[measureIndex];

				// If the bassNotes array does not exist for the measure, create it
				if (!measure.bassNotes) {
				    measure.bassNotes = [];
				}

				// Save the note at the appropriate beat within the measure
				// We'll use an object to store the beat and the note
				measure.soloNotes.push({
				    beat: beatWithinMeasure,
				    note: note
				});

				// Sort the bass notes by beat to maintain the correct order
				measure.bassNotes.sort((a, b) => a.beat - b.beat);
			} catch(err) {
			
			}
		}
		
		getSoloScale(time) {
			// Refer to table 1 in https://www.researchgate.net/publication/2342018_GenJam_A_Genetic_Algorithm_for_Generating_Jazz_Solos for the 
			var chord = this.getChordAtTime(time);
			var keyScale
			if(chord.key == 0)
				var keyScale = Tonal.Key.majorKey("C").scale;
			else
				keyScale = Tonal.Key.majorKey(Tonal.Key.majorTonicFromKeySignature(this.getFlatsSharps(chord.key))).scale;
			return keyScale
		}
		
		// The wave approximately the solo
		getSoloWave(time) {
			return Math.round(Math.cos(time / 3) * 5 + 67)
		}
		// Take an input of 60 and 4
		// Make it the closest mod 4 of 60, so 64 in this case
		getMidiClosestTo(scaled, inp) {
			var scaledInput = inp + (Math.round(scaled / 12)) * 12
			var scaledInput2 = inp + (Math.round(scaled / 12) + 1) * 12
			var scaledInput3 = inp + (Math.round(scaled / 12) - 1) * 12
			
			if(Math.abs(scaledInput - scaled) <= Math.abs(scaledInput2 - scaled) && 
			Math.abs(scaledInput - scaled) <= Math.abs(scaledInput3 - scaled)) {
				return scaledInput
			}
			
			
			if(Math.abs(scaledInput2 - scaled) <= Math.abs(scaledInput - scaled) && 
			Math.abs(scaledInput2 - scaled) <= Math.abs(scaledInput3 - scaled)) {
				return scaledInput2
			}
			
			if(Math.abs(scaledInput3 - scaled) <= Math.abs(scaledInput - scaled) && 
			Math.abs(scaledInput3 - scaled) <= Math.abs(scaledInput2 - scaled)) {
				return scaledInput3
			}
		}
		getSoloPointsWaveClosenessDeduction(time, strNote) {
			
			var midiSolo = this.getSoloWave(time)
			var converted = Tonal.Midi.toMidi(strNote + "0") % 12
			
			var midiVersion = this.getMidiClosestTo(midiSolo, converted)
			var offset = Math.abs(midiSolo - midiVersion)
			
			return -offset / 5
		}
		
		generateSolo() {
			/*
			Calculate probability for pausing briefly by calculating the completeness of the note
			
			Use the table found in https://www.researchgate.net/publication/2342018_GenJam_A_Genetic_Algorithm_for_Generating_Jazz_Solos for notes
			
			The basic rhythm should be created at the start
			
			The amount of notes initially should probably by 2-4, maybe one
			
			Lets define for one measure we generate the following
			
			- Dotted half + quarter
			
			We generate these simplistic completions until we reach a power of 2 and its reasonably resolved
			
			The probability of repeating said rhythm is also defined by a variable
			
			
			Measure 2
			
			- quarter - half - quarter
			
			
			Main idea for rhythm:
			
			Generate like a small phrase of maybe 2-10 notes to try and use as much as possible
			
			Notes for phrase should be 
			
			*/
			
			/*
			time offset for each note should be stored beforehand
			length of note is not stored
			*/
			
			var rhythmsArr = []
			
			var time = 0;
			
			var rhythmMade = new Tree({});
			var rhythmInts = rhythmMade.getRhythmArray()
			console.log(rhythmInts)
			var rhythmIndexer = 0;
			while(time < this.phraseLength * 4) {
				var noteLen = rhythmInts[rhythmIndexer % rhythmInts.length]
				//console.log(noteLen);
				rhythmsArr.push(noteLen);
				time += noteLen;
				rhythmIndexer+=1;
			}
			
			var bassTime = 0;
			var index = 0
			var previousBaseline = this.getSoloPoints(0, bassTime, rhythmsArr)[0];
			var noteBefore = -1
			while (bassTime < this.phraseLength * 4) { // Assuming 4 beats per measure
			    // Get the bass line options at the current time
			    var bassLineOptions = this.getSoloPoints(index, bassTime, rhythmsArr);
				this.getSoloComboPoints(previousBaseline, bassLineOptions)
			    if (bassLineOptions.length > 0) {
					// Select the best bass line option (the first one after sorting)
					
					var bestBassLineOption = bassLineOptions[0];
					
					// Write the first note of the best bass line to the measure
					for(var i = 0; i < bestBassLineOption.soloLine.length; i++) {
						var midiBass = 0
						if(noteBefore == -1)
							midiBass = this.getMidiClosestTo(this.getSoloWave(bassTime), Tonal.Midi.toMidi(bestBassLineOption.soloLine[i] + "0") % 12)
						else
							midiBass = this.getMidiClosestTo(noteBefore, Tonal.Midi.toMidi(bestBassLineOption.soloLine[i] + "0") % 12)
						
						/*
						if(midiBass < this.soloistLowerRange)
							midiBass += 12
						if(midiBass > this.soloistUpperRange)
							midiBass -= 12
						*/
						
						noteBefore = midiBass
						this.currentSoloistMidiNote = noteBefore
						this.writeSoloNote(bassTime, midiBass);
						bassTime += rhythmsArr[index+i]
					}
					previousBaseline = bestBassLineOption
			    }
				index+=3
				
				document.getElementById("completionProgress").innerHTML = "Generating Solo: " + Math.floor(bassTime / 4) + " / " + this.phraseLength + " measures";
			}
		}
		getChordAtTime(time) {
			for(var i = 0; i < this.phraseLength; i++) {
				for(var j = 0; j < this.measures[i].chords.length; j++) {
					time-=4.0/this.measures[i].chords.length
					if(time<0)
						return this.measures[i].chords[j]
				}
			}
			return this.measures[0].chords[0]
		}
		getSoloComboPoints(previousBass, nextGens) {
			/*
			Use the idea from the chord generation to make it as different as possible
			Each note that is found in nextGen should decrease the points by 0.75
			*/
			var newNextGens = []
			
			for(var i = 0; i < nextGens.length; i++) {
				var pointsAdding = 0
				var increasingAmount = 0
				
				for(var j = 1; j < nextGens[i].soloLine.length; j++) {
					// Approximately get increasing note or nah
					var intervalNum = parseInt(Tonal.Interval.distance(nextGens[i].soloLine[j], nextGens[i].soloLine[j-1]).slice(0,1))
					if(intervalNum < 5)
						increasingAmount+=intervalNum
					else
						increasingAmount-=8-intervalNum
					/*
					if(previousBass.soloLine.includes(nextGens[i].soloLine[j])) {
						pointsAdding -= .75
					}
					*/
					
				}
				
				//console.log(this.currentSoloistMidiNote)
				
				var meshedLine = [previousBass.soloLine[2], nextGens[i].soloLine[0], nextGens[i].soloLine[1]]
				var meshedLinePoints = this.calculateSoloPoints(meshedLine)
				pointsAdding += meshedLinePoints
				
				if(this.currentSoloistMidiNote + 15 > this.soloistUpperRange) {
					if(increasingAmount > 0)
						pointsAdding+=.5
				}
				
				if(this.currentSoloistMidiNote - 15 < this.soloistLowerRange) {
					if(increasingAmount < 0)
						pointsAdding+=.5
				}
				
				nextGens[i].thisPoints += pointsAdding
				
				
				var randomness = parseFloat(document.getElementById("randomness").value)
				nextGens[i].thisPoints += Math.random() * randomness
			}
			nextGens.sort((a, b) => b.thisPoints - a.thisPoints);
		}
		getBassPoints(time) {
		    // Retrieve the current chord based on the provided time
		    const currentChord = this.getChordAtTime(time);
		    const chordNotes = Tonal.Chord.get(currentChord.chord).notes;

		    // We will store the bass line options and their points here
		    let bassLineOptions = [];

		    // We will check the next two chords to form potential bass lines
		    const nextChord1 = this.getChordAtTime(time + 1);
		    const nextChord2 = this.getChordAtTime(time + 2);

		    // Get the notes for the next two chords
		    const nextChord1Notes = Tonal.Chord.get(nextChord1.chord).notes;
		    const nextChord2Notes = Tonal.Chord.get(nextChord2.chord).notes;

		    // Helper function to calculate points for a given bass line
		    function calculateBassPoints(bassNotes) {
			let points = 0;

			// Check for duplicate notes in the bass line
			const uniqueBassNotes = new Set(bassNotes);
			if (uniqueBassNotes.size !== bassNotes.length) {
			    // If there are duplicates, set points to zero and return
			    return 0;
			}

			// Check if the bass line forms a chromatic progression
			if (Tonal.Interval.distance(bassNotes[0], bassNotes[1]) === "1A" &&
			    Tonal.Interval.distance(bassNotes[1], bassNotes[2]) === "1A") {
			    points += 1.5; // Chromatic bass line
			}

			// Check if the bass line forms a triad (excluding diminished/augmented)
			if (Tonal.Chord.detect(bassNotes).some(chordName => chordName.includes("dim") || chordName.includes("aug"))) {
			    points += 0.5; // Diminished/Augmented triads
			} else if (Tonal.Chord.detect(bassNotes).length > 0) {
			    points += 1; // Triad
			}

			// Check if the bass line is a fifth progression (C - G - D for example)
			if (Tonal.Interval.distance(bassNotes[0], bassNotes[1]) === "5P" &&
			    Tonal.Interval.distance(bassNotes[1], bassNotes[2]) === "5P") {
			    points += 0.5; // Fifths bass line
			}

			return points;
		    }

		    // Generate all combinations of bass notes from the current and next two chords
		    for (let i = 0; i < chordNotes.length; i++) {
			for (let j = 0; j < nextChord1Notes.length; j++) {
			    for (let k = 0; k < nextChord2Notes.length; k++) {
				// Form a bass line using one note from each chord
				const bassLine = [chordNotes[i], nextChord1Notes[j], nextChord2Notes[k]];
				// Calculate the points for this bass line
				const points = calculateBassPoints(bassLine);
				// Add the bass line and its points to the options
				bassLineOptions.push({ bassLine, points });
			    }
			}
		    }

		    // Sort the bass line options by points in descending order
		    bassLineOptions.sort((a, b) => b.points - a.points);

		    // Return the sorted bass line options
		    return bassLineOptions;
		}
		
		// Helper function to calculate points for a given bass line
		calculateSoloPoints(bassNotes) {
			let points = 0;

			// Check for duplicate notes in the bass line
			const uniqueBassNotes = new Set(bassNotes);
			if (uniqueBassNotes.size !== bassNotes.length) {
				// If there are duplicates, set points to zero and return
				return -10;
			}
			
			var firstInterval = Tonal.Interval.distance(bassNotes[0], bassNotes[1])
			var secondInterval = Tonal.Interval.distance(bassNotes[1], bassNotes[2])
			
			var backwardsFirstInterval = Tonal.Interval.distance(bassNotes[2], bassNotes[1])
			var backwardsSecondInterval = Tonal.Interval.distance(bassNotes[1], bassNotes[0])
			
			// Fits to bounds
			var rangeFitterLower  = Math.pow(((this.currentSoloistMidiNote + 5) / this.soloistLowerRange), 5)
			var rangeFitterUpper = Math.pow(this.soloistLowerRange / (this.currentSoloistMidiNote - 10), 5)
			
			
			var chromaticProb = parseFloat(document.getElementById("chromaticProb").value)
			var scaleProb = parseFloat(document.getElementById("scaleProb").value)
			var dimProb = parseFloat(document.getElementById("dimProb").value)
			var triadProb = parseFloat(document.getElementById("triadProb").value)
			var reverseProb = parseFloat(document.getElementById("reverseProb").value)
			var resolveProb = parseFloat(document.getElementById("resolveProb").value)
			var fithsProb   = parseFloat(document.getElementById("fithsProb").value)
			
			
			// Check if the bass line forms a chromatic progression
			if ((firstInterval === "1A" || firstInterval === "2m") &&
				(secondInterval === "1A" || secondInterval === "2m")) {
				points += chromaticProb; // Chromatic bass line
			}
			
			// Check if the bass line forms a chromatic progression
			if ((backwardsFirstInterval === "1A" || backwardsFirstInterval === "2m") &&
				(backwardsSecondInterval === "1A" || backwardsSecondInterval === "2m")) {
				points += chromaticProb; // Chromatic bass line
			}
			
			
			// Moving up scales
			
			if ((firstInterval === "1A" || firstInterval === "2m") &&
				(secondInterval === "2M" || secondInterval === "2M")) {
				points += scaleProb; // First 3 notes of phygrian
			}
			
			if ((firstInterval === "2M" || firstInterval === "2M") &&
				(secondInterval === "2M" || secondInterval === "2M")) {
				points += scaleProb; // First 3 notes of major
			}
			
			if ((firstInterval === "2M") &&
				(secondInterval === "2m")) {
				points += scaleProb; // First 3 notes of minor
			}
			
			if ((backwardsFirstInterval === "1A" || backwardsFirstInterval === "2m") &&
				(backwardsSecondInterval === "2M" || backwardsSecondInterval === "2M")) {
				points += scaleProb; // First 3 notes of phygrian
			}
			
			if ((backwardsFirstInterval === "2M" || backwardsFirstInterval === "2M") &&
				(backwardsSecondInterval === "2M" || backwardsSecondInterval === "2M")) {
				points += scaleProb; // First 3 notes of major
			}
			
			// Various resolves
			
			if ((firstInterval === "2m") &&
				(secondInterval === "7M")) {
				points += reverseProb; // B - C - B, for example
			}
			
			if ((firstInterval === "6M") &&
				(secondInterval === "2m")) {
				points += resolveProb; // D B C for example
			}
			
			if ((firstInterval === "7m") &&
				(secondInterval === "2M")) {
				points += reverseProb; // D C D for example
			}
			
			
			// Chords

			// Check if the bass line forms a triad (excluding diminished/augmented)
			if (Tonal.Chord.detect(bassNotes).some(chordName => chordName.includes("dim") || chordName.includes("aug"))) {
				points += dimProb; // Diminished/Augmented triads
			} else if (Tonal.Chord.detect(bassNotes).some(chordName => chordName.includes("m") || chordName.includes("M"))) {
				// console.log(Tonal.Chord.detect(bassNotes))
				points += triadProb; // Triad
			}

			// Check if the bass line is a fifth progression (C - G - D for example)
			if (firstInterval === "5P" &&
				secondInterval === "5P") {
				points += fithsProb; // Fifths bass line
			}
			
			/*
			var soloWaves = [nextSoloWave0, nextSoloWave1, nextSoloWave2]
			var timeKeeper = time
			for(var i = 0; i < soloWaves.length; i++) {
				points += this.getSoloPointsWaveClosenessDeduction(timeKeeper, soloWaves[i])
				timeKeeper += rhythmsArr[index+i+1]
			}
			*/
		

			return points;
		}
		getSoloPoints(index, time, rhythmsArr) {
			/*
			Alot like the bass points algorithm
			This should also calculate the algorithm with the one before it
			Add them together then its basically the same
			*/
			
			
			// Retrieve the current chord based on the provided time
		    //const currentChord = this.getChordAtTime(time);
		    const chordNotes = this.getSoloScale(time);

		    // We will store the bass line options and their points here
		    let bassLineOptions = [];
			
		    // We will check the next two chords to form potential bass lines
		    const nextChord1Notes = this.getSoloScale(time + rhythmsArr[index]);
		    const nextChord2Notes = this.getSoloScale(time + rhythmsArr[index] + rhythmsArr[index+1]);
			
			
			const nextSoloWave0 = this.getSoloWave(time);
			const nextSoloWave1 = this.getSoloWave(time + rhythmsArr[index]);
			const nextSoloWave2	= this.getSoloWave(time + rhythmsArr[index] + rhythmsArr[index+1]);
			
		    // Generate all combinations of bass notes from the current and next two chords
		    for (let i = 0; i < chordNotes.length; i++) {
				for (let j = 0; j < nextChord1Notes.length; j++) {
					for (let k = 0; k < nextChord2Notes.length; k++) {
						// Form a bass line using one note from each chord
						var soloLine = [chordNotes[i], nextChord1Notes[j], nextChord2Notes[k]];
						
						var thisPoints = this.calculateSoloPoints(soloLine);
						// Add a bit of random to the solo
						// Add the bass line and its points to the options
						bassLineOptions.push({ soloLine, thisPoints });
					}
				}
		    }
			
		    // Sort the bass line options by points in descending order
		    bassLineOptions.sort((a, b) => b.thisPoints - a.thisPoints);
			
		    // Return the sorted bass line options
		    return bassLineOptions;
		}
		generateBass() {
			let bassTime = 0; // Initialize the timekeeper variable
			var timeIncrement = 1; // Define the time increment for bass notes

			// Loop through the phrase length, incrementing the timekeeper
			while (bassTime < this.phraseLength * 4) { // Assuming 4 beats per measure
			    // Get the bass line options at the current time
			    const bassLineOptions = this.getBassPoints(bassTime);
			    if (bassLineOptions.length > 0) {
				// Select the best bass line option (the first one after sorting)
				const bestBassLineOption = bassLineOptions[0];
				//console.log(bestBassLineOption);
				
				// Write the first note of the best bass line to the measure
				for(var i = 0; i < bestBassLineOption.bassLine.length; i++) {
					this.writeBassNote(bassTime, bestBassLineOption.bassLine[i]);
					bassTime += timeIncrement;
				}
			    }
			}
		    }
		generateChords() {
			this.measures.push(new Measure([new Chord("Dm7", 0, 3.75)]))
			for(var i = this.measures.length; i < this.phraseLength; i++) {
				this.keyChange()
				var nextChord = this.getNextChord(this.measures[i-1].chords)
				//console.log(nextChord);
				this.measures.push(new Measure([nextChord]))
				//console.log(this.currentKey)
			}
			
			// TODO: if points for chord are pretty low, try adding in another chord into the measure
		}
		generateMeasures() {
			this.generateChords()
			this.generateBass()
			this.generateSolo()
		}
	}
	
	
	
	var piece
	
	
	var intervalId = null
	
	// Add event listener to the button
	document.getElementById('play-chord').addEventListener('click', function() {
		piece = new Phrase(0, parseInt(document.getElementById("measaures").value));
		piece.generateMeasures();

		// Clear any existing interval
		if (intervalId !== null) {
			clearInterval(intervalId);
		}

		// Create a new interval
		intervalId = window.setInterval(function() {
			piece.playMeasure();
		}, 60 / piece.bpm * 4000);
	});
</script>

</div>
</div>

<object type="text/html" data="../footer2024.html" width=100%></object>
</body>
</html>
